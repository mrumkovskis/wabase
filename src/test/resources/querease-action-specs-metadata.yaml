table:   file_info
columns:
  - id
  - filename      ! 240
  - upload_time   !
  - content_type  ! 100
  - sha_256       ! file_body_info.sha_256

table:   file_body_info
columns:
  - sha_256 ! 64
  - size    ! long
  - path    ! 240
pk: sha_256

table: person
columns:
- id
- name                 ! 51
- surname                52
- sex                  ! 1   (M F)
- birthdate            ! date
- main_account.id        account.id

table: owner
columns:
- id
- name                 ! 100
- address              ! 100

table: forest
columns:
- id
- owner.id             !
- nr                   !
- area                 ! decimal 10 2
- trees                  64

table: tree
columns:
- id
- forest.id            !
- plant_date           ! date
- height                 decimal 10 2
- diameter               decimal 10 2

table: person_health
db: med_db
columns:
- id
- name                 ! 51
- manipulation_date    ! date
- vaccine                64
- had_virus              boolean

table: account
columns:
- id
- number               ! 64
- balance              ! decimal 10 2
- last_modified        ! dateTime
- person.id            !
uk:
- number

table: transaction
columns:
- id
- originator.id          account.id
- beneficiary.id       ! account.id
- amount               ! decimal 10 2
- date_time            ! dateTime

table: purchase
db: shop_db
columns:
- id
- customer            ! 64
- purchase_time       ! dateTime
- item                ! 256
- amount              ! decimal 10 2

table: if_and_foreach_test
columns:
- code                ! 40
- parent                40
- value                 64

table: simple_table
columns:
- id
- value                 64

name: person
api: save, get
table: person
fields:
- id
- name
- surname
- sex
- birthdate
- main_account = account a[a.id = (person p[p.id = :id] {main_account_id})] {number} -> = account[number = _]{id}
- accounts * :
    table: account
    fields:
    - id
    - number
    - balance
    - last_modified
validations:
  - build cursors
  - ac(# c) { accounts {count(*)} }, (ac{c}) > 0, "person must have at least one account"
save:
- validations:
  - build cursors
  - ac(# c) { accounts {count(*)} }, (ac{c}) <= 3, "person cannot have more than 3 accounts, instead '" || (ac{c}) || "' encountered"
  - transactions_balance(# number, balance, tr_balance) {
      (accounts pa_deb[originator_id = pa_deb.id] transaction deb_tr?
        { number, sum(amount) amount_deb }(pa_deb.number)) a_deb
      [a_deb.number = a_cre.number]
      (accounts pa_cre[beneficiary_id = pa_cre.id] transaction cre_tr?
        { number, sum(amount) amount_cre }(pa_cre.number)) a_cre
      [a_cre.number = a.number] accounts a
      { a.number, a.balance, coalesce(amount_cre - amount_deb, 0) }
    }, wrong_balances(# number, balance, tr_balance) {
      transactions_balance tb[balance != tr_balance] { number, balance, tr_balance }
    }, (wrong_balances{count(*)}) = 0,
    "Wrong balance for accounts '" || (wrong_balances{group_concat(number || '(' || balance || ' != ' || tr_balance || ')')}) || "'"
- setenv org.wabase.QuereaseActionTestManager.personSaveDtoBizMethod
- setenv org.wabase.QuereaseActionTestManager.personSaveBizMethod
- setenv org.wabase.QuereaseActionTestManager.personSaveJavaMapBizMethod
- save this
- org.wabase.QuereaseActionTestManager.sendNotifications
- get this


name: person_simple
table: person
fields:
- id
- name
# surname
- sex
- birthdate


name: person_accounts_details
table: person
fields:
- id
- name
- surname
- main_account  person_accounts
- accounts *    person_accounts
- balances *    =


name: payment
api: save, get
table: transaction tr
joins:
- tr[tr.originator_id = originator.id]account originator?
- tr[tr.beneficiary_id = beneficiary.id]account beneficiary?
fields:
- id
- originator  = originator.number  -> = account [number = _] { id }
- beneficiary = beneficiary.number -> = account [number = _] { id }
- amount
- date_time -> = :time
save:
- validations amount:
  - :amount > 0, 'Wrong amount ' || :amount || '. Amount must be greater than 0'
- validations balance:
  - balance(# s) { account[number = :originator] {balance} }, ((balance{s}) = null | (balance{s}) >= :amount),
      "Insufficient funds for account '" || :originator || "'"
- time = now()
- save this
- =account[number = :originator] { balance, last_modified } [balance - :amount, :time]
- =account[number = :beneficiary] { balance, last_modified } [balance + :amount, :time]
- :id


name: person_list
table: person
fields:
- id
- name
- surname
- sex
- birthdate
filter:
- name %~~%
- surname %~~%
list:
- c: count this   # named step supports also colon notation
- d: list  this   # named step supports also colon notation
- return (count = :c) + (data = :d)


name: person_with_main_account
table:
fields:
- id
get:
- person = get person
- main_acc_id = coalesce((account[number = :person.main_account] {id}), -1)
- account = (id = :main_acc_id) -> get person_accounts
- main_account_data = if_defined_or_else(:account.number, :account.number || '(' || :account.balance || ')', '<no main account>')
- return :person + (main_account = :main_account_data)


name: person_health
api: save, get
db: med_db
table: person_health
fields:
- id
- name
- manipulation_date
- vaccine
- had_virus
save:
- validations check_person:
  - (person[name = :name]{count(1)}) > 0, "Person '" || :name || "' must be registered"
- save this
- redirect |med_db:{'person_health', :name, :manipulation_date::date, '?', 'val1' par1, 'val2' par2 }


name: person_health_priv
extends: person_health
api: save, get
db: med_db
table: person_health
fields:
- id
save:
- name = :current_person
- save person_health


name: person_with_health_data
api: list
table: person p
fields:
- name
- sex
- birthdate
- health * [p.name = ph.name]:
    db: med_db
    table:  person_health ph
    fields:
    - manipulation_date
    - vaccine
    - had_virus
    order:
    - manipulation_date
filter:
- name in :names
order:
- name


name: person_health_and_shop
api: list
table: person p
fields:
- name
- sex
- birthdate
- health * [p.name = ph.name]:
    db: med_db
    table:  person_health ph
    fields:
    - manipulation_date
    - vaccine
    - had_virus
    order:
    - manipulation_date
- purchases * [p.name = prch.customer]:
    db: shop_db
    table: purchase prch
    fields:
    - customer
    - purchase_time
    - item
    - amount
    order:
    - id
filter:
- name in :names
order:
- name


name: purchase
api: save, get, list, count, delete
db: shop_db
table: purchase
fields:
- id:
    sortable: true
- customer
- purchase_time
- item
- amount
filter:
- purchase_time
- customer
save:
- validations is_vaccinated [med_db]:
    - exists(person_health[name = :customer & vaccine != null]{1}), "Pardon, customer '" || :customer || "' is not vaccinated..."
- validations has_funds:
    - funds(# s) { account[person_id = (person[name = :customer]{id})] {max(balance)} },
        (funds{s}) >= :amount, "Insufficient funds, available (" || (funds{s}) || ")"
- commit
- save this
get:
- null{:purchase_time, :customer}    # ensure bind variable existence (must prefix columns with null table due to yaml parser)
- unique_opt list this
delete:
- -shop_db:purchase [purchase_time = :purchase_time & customer = :customer]


name: purchase_get
api: get
db: shop_db
table: purchase
fields:
- customer
- purchase_time
- item
- amount
get:
- unique_opt |shop_db:purchase[purchase_time = :purchase_time & customer = :customer]
    {item, amount}


name:     env_test_1
api:      save
table:    person
auth get: :update_enabled = true
fields:
- id
- name
- sex
- birthdate
save:
- name = :current_person_name
- sex  = 'M'
- save this


name:         env_test_2
api:          get, save
auth get:     true
auth update:  :update_enabled = true
extends:      env_test_1
fields:
- surname
save:
- save env_test_1
- setenv get env_test_1
- surname = :current_person_surname
- update this


name:         env_test_3
api:          get, save
auth get:     true
auth update:  :current_person_surname = 'EnvTestSurname'
extends:      env_test_1
fields:
- surname
save:
- save env_test_1
- setenv get env_test_1
- surname = :current_person_surname
- update this


name:         env_test_4
api:          get, save
auth get:     true
extends:      env_test_1
save:
- name = 'Mika'
- save this
filter:
- sex


name:   status_test_1
table:
api:    get, save, list, count
fields:
- status =
get:
- status ok
save:
- status ok :status
count:
- status ok {:status}[false]  # should return 200 with no message in response
list:
- status { 303, '/data', 'path', :status }


name:   status_test_2
table:
api:    get, save, list, count
fields:
  - id
get:
  - redirect { 'data/path', :id }
save:
  - redirect { 'data/path', '?', :id id }
count:
  - redirect { 'data/path' }
list:
  - redirect { 'data/path', '?' }


name:   status_test_3
table:
api:    get, save, list, count
fields:
  - id
save:
  - status { 303 }
get:
  - redirect { 'data/path/' || :id }
list:
  - status { 303, 'data/path', :id, '?', 'val-of-par1' par1 }
count:
  - redirect { null, :id, '?', (:id + 1) par1 }


name:   status_test_4
table:
api:    get, save, list, count
fields:
  - id
save:
  - redirect { 'data/path', :id }
get:
  - redirect { 'data/path', '?', :id id }
list:
  - redirect { 'data/path/' || :id }


name: invocation_test_1
table:
api: get, save, count
fields:
- s1
- s2
- n1
- n2
get:
- s1 = 'val1'
- s2 = 'val2'
- s3 = org.wabase.QuereaseActionTestManager.concatStrings
- status ok { :s3 }
save:
- n1 = 1
- n2 = 1.5
- n3 = org.wabase.QuereaseActionTestManager.addNumbers
- return (nr = :n3)


name: if_test_1
table: if_and_foreach_test
api: save
fields:
- code
- parent
- value
save:
- code = 'if_test_1'
- if {:value = 'yes'} :
    - value = :value || '_value'
    - +if_and_foreach_test{code = :code, value = :value}
- if {:value = 'no'} :
    - value = :value || '_value'
    - =if_and_foreach_test[code = :code]{value = :value}
- unique_opt if_and_foreach_test[code = :code]{code, value}


name: if_test_2
table:
api: get, list
fields:
- value
get:
- res:
    if :value :
      - null{'yes'} # somehow cannot use simply {'yes'} because yaml parser parses it as a Map - {yes=null} not simple value ?
- status ok :res
list:
- res = 'init'
- get this


name: foreach_test_1
table: if_and_foreach_test ift
api: get, save
key: code
fields:
- code
- parent
- value
- children[!] * [:1(code) = parent]foreach_test_1
save:
- insert this
- foreach :children :
    - parent = :'..'.code
    - insert this
- get this
update:
- update this
- foreach :children :
    - parent = :'..'.code
    - update this
- get this

name: foreach_test_2
extends: foreach_test_1
api: get, save
save:
- insert this
- if { :value = 'new' } :
    - foreach :children :
       - if { :value = 'new child' } :
           - parent = :'..'.code
           - insert this
- get this


name:   insert_update_test_1
table:  simple_table
api:    get, save
fields:
- id
- value
insert:
- value = 'INS'
- insert this
- get this
update:
- value = 'UPD'
- update this
- get this


name: result_audit_test
table: simple_table
api:   get
fields:
- id
- value
get:
- +simple_table{ id = :id, value = 'data' }
- get this


name: remove_var_test
table:
api: insert, update
fields:
- var1
- var2
insert:
- var2 -=   # removes variable from environment
update:
- x    -=   # not existing var
- var1 -=   # removes variable from environment


name: to_file_test1
table: person
api: list
fields:
- name
- surname
- sex
order:
- surname
list:
- to file list this
- to file (list this) 'persons'
- to file (list this) 'persons' 'application/json'


name: to_file_test2
table: person
api: list
fields:
- name
- surname
- sex
order:
- surname
list:
- file = to file (list this) 'persons'
- file {:file.id, :file.sha_256}      # to get file both id and sha must be specified


name: to_file_test3
table:
api: list
list:
  - file = to file |shop_db:purchase{customer, item}#(1,2) 'purchases'
  - file {:file.id, :file.sha_256}      # to get file both id and sha must be specified


name: conf_test
table:
api: list, get
get:
- uri = conf string conf.test.uri
- status ok { :uri || 'about' }
list:
- conf conf.test


name: http_test_1
table:
api: get
get:
- http '/invocation_test_1'


name: http_test_2
table:
key: name
api: get, list, save
fields:
- id
- name
- manipulation_date
- vaccine
get:
- unique_opt {:name name, :manipulation_date::date manipulation_date, :vaccine vaccine, :id::long id}
list:
- res = http '/invocation_test_1'
- status ok :res
insert:
  # http post ends with empty array explicitly indicating no headers
- res = http post '/person_health'
          unique_opt { 'Mr. Mario' name, 'Moderna' 'vaccine', '2022-04-11' 'manipulation_date' }
          []
- status ok :res
update:
- health_id = unique_opt |med_db:person_health[name = :name]{id}
- http put { '/person_health/' || :health_id.id }
    http get
      {'/http_test_2/' || :name, '?', :manipulation_date manipulation_date, :vaccine vaccine, :health_id.id id }


name: owner
table: owner
key: name
api: get, save, list
fields:
- name
- address
explicit db: true
get:
- res:
    db use:
      - get this
- :res
save:
- transaction:
  - save this


name: forest
table: forest
key: nr
api: get, save, list
fields:
- nr
- owner = owner.name -> = owner[name = _] {id}
- area
- trees
save:
- save this as forest http { '/http_forest', '?', :nr nr, :owner owner, :area area, :trees trees }


name: http_forest
api: get, update
key: nr
table:
fields:
- nr [!]  # not updatable to ensure that appears in http url
- owner
- area decimal 10 2
- trees
get:
- unique_opt { :nr nr, :owner owner, :area::decimal area, :trees trees }
update:
- forest = http { '/forest', :nr }
- :forest + :_ -> http put {'/forest/', :nr } get http_forest


name: json_codec_1
api: get, insert
table:
fields:
- nr
- owner
- trees
- area
- notes
filter:
- :value
get:
- from json :value
insert:
- forest = from json :value
- http post '/forest' to json
    unique_opt { :forest.nr nr, :forest.owner owner, :forest.trees trees, :forest.area::decimal area }


name: last_step_assignment_test
api: get
table:
fields:
- nr
- value
get:
- value = :param
filter:
- :param


name: tree
table: tree
api: list, save
fields:
- id
- forest = forest.nr -> = forest[nr = _] {id}
- plant_date
- height
- diameter
filter:
- forest_id = (forest[nr = :nr?] {id})


name: forest_with_trees
extends: forest
fields:
- tree_list * :
    table:
    fields:
    - id
    - plant_date  date
    - height      decimal 10 2
    - diameter    decimal 10 2


name: owner_with_forest_with_trees
extends: owner
api: get
fields:
- forests * forest_with_trees
get:
- res:      # assign db data to variable so that during http request db connection is closed
    db use:
    - get this
- setenv :res
- forests:
    foreach :forests :
    - tree_list = as tree * http { '/tree', '?', :nr nr }
    - "'..'-="  # remove super data for easier assertion

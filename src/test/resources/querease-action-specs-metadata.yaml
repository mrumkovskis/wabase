table: person
columns:
- id
- name                 ! 51
- surname                52
- sex                  ! 1   (M F)
- birthdate            ! date
- main_account.id        account.id

table: person_health
db: med_db
columns:
- id
- name                 ! 51
- manipulation_date    ! date
- vaccine                64
- had_virus              boolean

table: account
columns:
- id
- number               ! 64
- balance              ! decimal 10 2
- last_modified        ! dateTime
- person.id            !
uk:
- number

table: transaction
columns:
- id
- originator.id          account.id
- beneficiary.id       ! account.id
- amount               ! decimal 10 2
- date_time            ! dateTime

table: purchase
db: shop_db
columns:
- id
- customer            ! 64
- purchase_time       ! dateTime
- item                ! 256
- amount              ! decimal 10 2


name: person
api: save, get
table: person
fields:
- id
- name
- surname
- sex
- birthdate
- main_account = account a[a.id = (person p[p.id = :id] {main_account_id})] {number} -> = account[number = _]{id}
- accounts * :
    table: account
    fields:
    - id
    - number
    - balance
    - last_modified
validations:
  - build cursors
  - ac(# c) { accounts {count(*)} }, (ac{c}) > 0, "person must have at least one account"
save:
- validations:
  - build cursors
  - ac(# c) { accounts {count(*)} }, (ac{c}) <= 3, "person cannot have more than 3 accounts, instead '" || (ac{c}) || "' encountered"
  - transactions_balance(# number, balance, tr_balance) {
      (accounts pa_deb[originator_id = pa_deb.id] transaction deb_tr?
        { number, sum(amount) amount_deb }(pa_deb.number)) a_deb
      [a_deb.number = a_cre.number]
      (accounts pa_cre[beneficiary_id = pa_cre.id] transaction cre_tr?
        { number, sum(amount) amount_cre }(pa_cre.number)) a_cre
      [a_cre.number = a.number] accounts a
      { a.number, a.balance, coalesce(amount_cre - amount_deb, 0) }
    }, wrong_balances(# number, balance, tr_balance) {
      transactions_balance tb[balance != tr_balance] { number, balance, tr_balance }
    }, (wrong_balances{count(*)}) = 0,
    "Wrong balance for accounts '" || (wrong_balances{group_concat(number || '(' || balance || ' != ' || tr_balance || ')')}) || "'"
- setenv org.wabase.QuereaseActionTestManager.personSaveDtoBizMethod
- setenv org.wabase.QuereaseActionTestManager.personSaveBizMethod
- setenv org.wabase.QuereaseActionTestManager.personSaveJavaMapBizMethod
- save this
- org.wabase.QuereaseActionTestManager.sendNotifications
- get this


name: person_simple
table: person
fields:
- id
- name
# surname
- sex
- birthdate


name: person_accounts_details
table: person
fields:
- id
- name
- surname
- main_account  person_accounts
- accounts *    person_accounts
- balances *    =


name: payment
api: save, get
table: transaction tr
joins:
- tr[tr.originator_id = originator.id]account originator?
- tr[tr.beneficiary_id = beneficiary.id]account beneficiary?
fields:
- id
- originator  = originator.number  -> = account [number = _] { id }
- beneficiary = beneficiary.number -> = account [number = _] { id }
- amount
- date_time -> = :time
save:
- validations amount:
  - :amount > 0, 'Wrong amount ' || :amount || '. Amount must be greater than 0'
- validations balance:
  - balance(# s) { account[number = :originator] {balance} }, ((balance{s}) = null | (balance{s}) >= :amount),
      "Insufficient funds for account '" || :originator || "'"
- time = now()
- save this
- =account[number = :originator] { balance, last_modified } [balance - :amount, :time]
- =account[number = :beneficiary] { balance, last_modified } [balance + :amount, :time]
- :id


name: person_list
table: person
fields:
- id
- name
- surname
- sex
- birthdate
filter:
- name %~~%
- surname %~~%
list:
- c: count this   # named step supports also colon notation
- d: list  this   # named step supports also colon notation
- return (count = :c) + (data = :d)


name: person_with_main_account
table:
fields:
- id
get:
- person = get person
- main_acc_id = coalesce((account[number = :person.main_account] {id}), -1)
- account = (id = :main_acc_id) -> get person_accounts
- main_account_data = if_defined_or_else(:account.number, :account.number || '(' || :account.balance || ')', '<no main account>')
- return :person + (main_account = :main_account_data)


name: person_health
api: save, get
db: med_db
table: person_health
fields:
- id
- name
- manipulation_date
- vaccine
- had_virus
save:
- validations check_person:
  - (person[name = :name]{count(1)}) > 0, "Person '" || :name || "' must be registered"
- save this
- redirect |med_db:{'person_health', :name, :manipulation_date, '?', 'val1' par1, 'val2' par2 }


name: person_health_priv
extends: person_health
api: save, get
db: med_db
table: person_health
fields:
- id
save:
- name = :current_person
- save person_health


name: person_with_health_data
api: list
table: person p
fields:
- name
- sex
- birthdate
- health * [p.name = ph.name]:
    db: med_db
    table:  person_health ph
    fields:
    - manipulation_date
    - vaccine
    - had_virus
    order:
    - manipulation_date
filter:
- name in :names
order:
- name


name: person_health_and_shop
api: list
table: person p
fields:
- name
- sex
- birthdate
- health * [p.name = ph.name]:
    db: med_db
    table:  person_health ph
    fields:
    - manipulation_date
    - vaccine
    - had_virus
    order:
    - manipulation_date
- purchases * [p.name = prch.customer]:
    db: shop_db
    table: purchase prch
    fields:
    - customer
    - purchase_time
    - item
    - amount
    order:
    - id
filter:
- name in :names
order:
- name


name: purchase
api: save, get, list, count, delete
db: shop_db
table: purchase
fields:
- id:
    sortable: true
- customer
- purchase_time
- item
- amount
filter:
- purchase_time
- customer
save:
- validations is_vaccinated [med_db]:
    - exists(person_health[name = :customer & vaccine != null]{1}), "Pardon, customer '" || :customer || "' is not vaccinated..."
- validations has_funds:
    - funds(# s) { account[person_id = (person[name = :customer]{id})] {max(balance)} },
        (funds{s}) >= :amount, "Insufficient funds, available (" || (funds{s}) || ")"
- commit
- save this
get:
- null{:purchase_time, :customer}    # ensure bind variable existence (must prefix columns with null table due to yaml parser)
- unique_opt list this
delete:
- -shop_db:purchase [purchase_time = :purchase_time & customer = :customer]


name: purchase_get
api: get
db: shop_db
table: purchase
fields:
- customer
- purchase_time
- item
- amount
get:
- unique_opt |shop_db:purchase[purchase_time = :purchase_time & customer = :customer]
    {item, amount}


name:     env_test_1
api:      save
table:    person
auth get: :update_enabled = true
fields:
- id
- name
- sex
- birthdate
save:
- name = :current_person_name
- sex  = 'M'
- save this


name:         env_test_2
api:          get, save
auth get:     true
auth update:  :update_enabled = true
extends:      env_test_1
fields:
- surname
save:
- save env_test_1
- setenv get env_test_1
- surname = :current_person_surname
- update this


name:         env_test_3
api:          get, save
auth get:     true
auth update:  :current_person_surname = 'EnvTestSurname'
extends:      env_test_1
fields:
- surname
save:
- save env_test_1
- setenv get env_test_1
- surname = :current_person_surname
- update this


name:   status_test_1
table:
api:    get, save, list, count
fields:
- status =
get:
- status ok
save:
- status ok :status
count:
- status ok {:status}[false]  # should return 200 with no message in response
list:
- status { 303, '/data', 'path', :status }


name:   status_test_2
table:
api:    get, save, list, count
fields:
  - id
get:
  - redirect { 'data/path', :id }
save:
  - redirect { 'data/path', '?', :id id }
count:
  - redirect { 'data/path' }
list:
  - redirect { 'data/path', '?' }


name:   status_test_3
table:
api:    get, save, list, count
fields:
  - id
save:
  - status { 303 }
